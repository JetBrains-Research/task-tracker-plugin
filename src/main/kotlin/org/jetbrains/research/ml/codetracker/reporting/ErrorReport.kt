package org.jetbrains.research.ml.codetracker.reporting

import com.intellij.openapi.diagnostic.SubmittedReportInfo
import com.intellij.openapi.diagnostic.SubmittedReportInfo.SubmissionStatus
import org.eclipse.egit.github.core.Issue
import org.eclipse.egit.github.core.Label
import org.eclipse.egit.github.core.RepositoryId
import org.eclipse.egit.github.core.client.GitHubClient
import org.eclipse.egit.github.core.service.IssueService
import java.util.*

/**
 * Provides functionality to create and send GitHub issues when an exception is thrown by a plugin.
 */
object ErrorReport {
    private const val TOKEN_FILE = "errorReporterToken"
    private const val GIT_REPO_USER = "JetBrains-Research"
    private const val GIT_REPO = "codetracker"
    private const val ISSUE_LABEL_BUG = "bug"
    private const val ISSUE_LABEL_AUTO_GENERATED = "auto-generated"
    private const val GIT_ISSUE_TITLE = "[auto-generated] %s"
    private const val HTML_URL_TO_CREATE_NEW_ISSUE = "https://github.com/JetBrains-Research/codetracker/issues/new"

    fun sendFeedback(errorInformation: ErrorInformation): SubmittedReportInfo? {
        return try {
            val client = GitHubClient()
            client.setOAuth2Token(
                GitHubAccessTokenDecoder.decrypt(
                    ErrorReport::class.java.getResourceAsStream(
                        TOKEN_FILE
                    )
                )
            )
            val repoID = RepositoryId(GIT_REPO_USER, GIT_REPO)
            val issueService = IssueService(client)
            var newGibHubIssue: Issue = createNewGibHubIssue(errorInformation)
            val duplicate: Issue? = findFirstDuplicate(
                newGibHubIssue.title,
                issueService,
                repoID
            )
            var isNewIssue = false
            if (duplicate != null) {
                val newErrorComment: String = generateGitHubIssueBody(errorInformation)
                issueService.createComment(repoID, duplicate.number, newErrorComment)
                newGibHubIssue = duplicate
            } else {
                newGibHubIssue = issueService.createIssue(repoID, newGibHubIssue)
                isNewIssue = true
            }
            val submissionStatus = if (isNewIssue) SubmissionStatus.NEW_ISSUE else SubmissionStatus.DUPLICATE
            SubmittedReportInfo(
                newGibHubIssue.htmlUrl,
                "Send bug report",
                submissionStatus
            )
        } catch (e: Exception) {
            SubmittedReportInfo(
                HTML_URL_TO_CREATE_NEW_ISSUE,
                "Don't send bug report",
                SubmissionStatus.FAILED
            )
        }
    }

    private fun createNewGibHubIssue(errorInformation: ErrorInformation): Issue {
        val gitHubIssue = Issue()
        gitHubIssue.title = String.format(
            GIT_ISSUE_TITLE,
            errorInformation.getErrorInformation(ErrorInformationType.ERROR_MESSAGE)
        )
        gitHubIssue.body = generateGitHubIssueBody(errorInformation)
        val bugLabel = Label()
        bugLabel.name = ISSUE_LABEL_BUG
        val autoGeneratedLabel = Label()
        autoGeneratedLabel.name = ISSUE_LABEL_AUTO_GENERATED
        gitHubIssue.labels = listOf(autoGeneratedLabel, bugLabel)
        return gitHubIssue
    }

    private fun generateGitHubIssueBody(errorInformation: ErrorInformation): String {
        val result = StringBuilder()
        enumValues<UserInformationType>().forEach {
            result.append("- ${it.readableValue}: ${errorInformation.getUserInformation(it)}\n")
        }
        result.append(
            "\n```\n${errorInformation.getErrorInformation(ErrorInformationType.ERROR_STACKTRACE)}" +
                    "\n```\n"
        )
        return result.toString()
    }

    private fun findFirstDuplicate(
        uniqueTitle: String,
        service: IssueService,
        repo: RepositoryId
    ): Issue? {
        val searchParameters: HashMap<String, String> = hashMapOf(IssueService.FILTER_STATE to IssueService.STATE_OPEN)
        return service.pageIssues(repo, searchParameters).flatten().find { it.title == uniqueTitle }
    }
}